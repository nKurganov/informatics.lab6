#include "Vector.h"
#include <iostream>

using namespace std;

void main() 
{
	Vector a(5);
	cout << a << "\n";
	cin >> a;
	cout << a << "\n";
	a[2] = 100;
	cout << a << "\n";
	Vector b(10);
	cout << b << "\n";
	b = a;
	cout << b << "\n";
	Vector c(10);
	c = b + 100;
	cout << c << "\n";
	cout << "\nthe length of a=" << a() << endl;
	cout << *(a.first())<<endl;
	Iterator i = a.first();
	++i;
	cout << *i << endl;
	for(i=a.first(); i!=a.last(); ++i) cout << *i << endl;
	for (i = a.first(); i != a.last(); i++) cout << *i << endl;
}
//Вопросы
//1. Тип данных, определяемы только через операции, которые могут выполняться над соответствующими объектами
//Например атд можно считать использование функции для разных классов которые предком которых является 1 и тот же абстрактный класс.
//2. Использование 1 и той-же функции для разных переменных
//3. Использование 1 и той-же функции для разных классов из 1 
//4. Контейнер - набор однотипных элементов. Частный случай массив.
//5. Операции доступа к элементам, которые обеспечивают и операцию замены значений элементов
//	 Операции добавления удаления
//	 Операция поиска
//	 Операция объединения контейнеров
//	 Специальные операцииЮ зависящие от вида контейнера
// 6. Прямой доступ - доступ по индексу (a[10] - 10 элемент массива a)
//	  Ассоциативный доступ - доступ по идентификатору который выступает в роли индекса (a["abc"] передаёт элемент с именем abc )
//    Последовательный доступ - от элемента к элементу при помощи различный функций (a.first() - передаёт первый элемент)
// 7. Итератор это объект, который обеспечивает последовательный доступ к элементам контейнера.
// 8. Итератор можно реализовать как класс, представляющий такой же набор операций. Итератор реализуется как класс, который имеет такой же интерфейс
// 9. Можно реализовать как объединения множеств в новый контейнер  попадают только те элементы которые есть хотя бы в 1 контейнере
// 10. Предоставляет доступ к значению элемента по ключу (ассоциативный контейнер)
// 11. Last in first out
// 12. d
// 13. c
// 14. Прямой доступ
// 15. Последовательный доступ 
// 
//